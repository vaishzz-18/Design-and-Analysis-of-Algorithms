<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            width: 80%;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
        h1 {
            text-align: center;
            color: #003366;
        }
        h2 {
            color: #003366;
            margin-top: 30px;
            background-color: #d9f2ff;
            padding: 10px;
            border-radius: 5px;
        }
        p {
            line-height: 1.6;
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table th, table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        table th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Reflections</h1>

        <h2>What are the kinds of problems we see in transportation?</h2>
        <p>
            Transportation systems encounter various challenges, such as inefficiencies in energy use, environmental degradation, and congestion. 
            For example, fossil fuel dependency contributes to greenhouse gas emissions, while outdated infrastructure struggles to meet the needs 
            of growing populations. These issues mirror natural problems like resource scarcity and flow dynamics. By studying nature's solutions, 
            such as the energy efficiency of migratory birds or the coordination of ant colonies, we can identify innovative approaches to improve 
            transportation systems.
        </p>

        <h2>What is space and time efficiency? Why are they important?</h2>
        <p>
            Space efficiency is about how much memory a program uses, while time efficiency measures how quickly it runs. Both are crucial because 
            resources like memory and time are limited. Imagine an app that crashes your phone because it uses too much memory or a program that 
            takes hours to process simple tasks—it wouldn’t be practical or effective. Efficiency ensures that software runs smoothly, even as the 
            amount of data grows or devices become smaller with less capacity.
        </p>

        <h2>Takeaway from different design principles from Chapter 2</h2>
        <table>
            <thead>
                <tr>
                    <th>Design Principle</th>
                    <th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Modular Design</td>
                    <td>Divides problems into smaller parts, making them easier to tackle and debug.</td>
                </tr>
                <tr>
                    <td>Divide and Conquer</td>
                    <td>Breaks problems into halves, solves each, and combines results for efficiency.</td>
                </tr>
                <tr>
                    <td>Optimization</td>
                    <td>Focuses on improving efficiency through techniques like dynamic programming.</td>
                </tr>
            </tbody>
        </table>

        <h2>The hierarchical data and how different tree data structures solve problems</h2>
        <p>
            Hierarchical data is everywhere—file systems, organization charts, or game levels. Trees are perfect for managing this kind of data. 
            Binary search trees are great for quickly searching and sorting. AVL trees and red-black trees ensure balance, so operations are 
            consistent even with uneven data. Heaps are a lifesaver when managing priorities, like scheduling tasks. These structures aren’t 
            just abstract concepts—they help solve real problems efficiently.
        </p>

        <h2>The need for array query algorithms and their implications</h2>
        <p>
            Imagine trying to get answers about sections of a giant dataset repeatedly—doing it from scratch every time would be painfully slow. 
            That’s where array query algorithms come in. For example, segment trees help with range-based queries like summing numbers in a range 
            or finding a maximum. Fenwick trees make updates fast while keeping everything organized. These tools make handling large amounts of 
            data more manageable and efficient, especially in applications like databases and coding competitions.
        </p>

        <h2>Differentiate between trees and graphs and their traversals</h2>
        <p>
            Trees and graphs both deal with nodes and connections, but they’re used for different purposes. Trees are like organized family 
            trees—everything follows a hierarchy, and there’s only one way to connect any two nodes. Graphs are messier, like a web, with 
            connections going anywhere. Traversals like DFS and BFS help explore these structures, whether it’s for hierarchical trees or 
            networks like maps and social media connections.
        </p>

        <h2>Deliberate on sorting and searching algorithms</h2>
        <p>
            Sorting and searching are the backbone of efficient data handling. Sorting makes things easier to find or use later, like alphabetizing 
            a list of contacts. Algorithms like quicksort and merge sort ensure this is done in a smart way. Searching, on the other hand, helps 
            pinpoint what you need—binary search is super fast but needs sorted data, while linear search works everywhere but can be slow. Together, 
            they keep data accessible and usable.
        </p>

        <h2>The importance of graph algorithms</h2>
        <p>
            Graph algorithms are essential for solving real-world problems, like finding the shortest route on Google Maps. They optimize connections 
            in transportation, communication, or social networks. Algorithms like Dijkstra’s for shortest paths or Kruskal’s for building efficient 
            networks are practical tools that directly impact areas like logistics and network design. They’re fascinating because they mirror real 
            challenges we face daily.
        </p>

        <h2>Different studied algorithm design techniques</h2>
        <p>
            The different design techniques we learned—like greedy algorithms, dynamic programming, and divide-and-conquer—all stood out for how 
            systematic they are. Greedy algorithms are like quick decisions that work for problems like building an efficient file compression. 
            Dynamic programming is about carefully building on smaller solutions, like solving puzzles one piece at a time. Divide-and-conquer, 
            meanwhile, felt like breaking a big task into manageable parts—something we do in everyday life, like organizing a big project. 
            These approaches make solving complex problems a lot simpler.
        </p>
    </div>
</body>
</html>